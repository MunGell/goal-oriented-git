<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <meta name="generator" content="pandoc">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">
  <meta name="author" content="George Brocklehurst">
  <title>Goal-Oriented Git</title>
  <style type="text/css">code{white-space: pre;}</style>
  <!--[if lt IE 9]>
    <script src="http://html5shim.googlecode.com/svn/trunk/html5.js"></script>
  <![endif]-->
  <link href="data:text/css,%2A%20%7B%0A%20%20%2Dmoz%2Dbox%2Dsizing%3A%20border%2Dbox%3B%0A%20%20%2Dwebkit%2Dbox%2Dsizing%3A%20border%2Dbox%3B%0A%20%20box%2Dsizing%3A%20border%2Dbox%3B%20%7D%0A%0Abody%20%7B%0A%20%20font%2Dsize%3A%201em%3B%0A%20%20height%3A%20100%25%3B%0A%20%20margin%3A%200%20auto%3B%0A%20%20max%2Dwidth%3A%2054em%3B%0A%20%20padding%3A%200%201em%204%2E5em%3B%20%7D%0A%20%20%40media%20screen%20and%20%28min%2Dwidth%3A%20600px%29%20%7B%0A%20%20%20%20body%20%7B%0A%20%20%20%20%20%20padding%3A%200%204em%204%2E5em%3B%20%7D%20%7D%0A%20%20%40media%20screen%20and%20%28min%2Dwidth%3A%20700px%29%20%7B%0A%20%20%20%20body%20%7B%0A%20%20%20%20%20%20font%2Dsize%3A%201%2E125em%3B%20%7D%20%7D%0A%20%20%40media%20screen%20and%20%28min%2Dwidth%3A%20800px%29%20%7B%0A%20%20%20%20body%20%7B%0A%20%20%20%20%20%20padding%3A%200%206em%204%2E5em%3B%20%7D%20%7D%0A%20%20%40media%20screen%20and%20%28min%2Dwidth%3A%20880px%29%20%7B%0A%20%20%20%20body%20%7B%0A%20%20%20%20%20%20padding%3A%200%208em%204%2E5em%3B%20%7D%20%7D%0A%20%20%40media%20screen%20and%20%28min%2Dwidth%3A%20940px%29%20%7B%0A%20%20%20%20body%20%7B%0A%20%20%20%20%20%20padding%3A%200%2010em%204%2E5em%3B%20%7D%20%7D%0A%20%20%40media%20screen%20and%20%28min%2Dwidth%3A%201800px%29%20%7B%0A%20%20%20%20body%20%7B%0A%20%20%20%20%20%20font%2Dsize%3A%201%2E375em%3B%20%7D%20%7D%0A%0Anav%20%7B%0A%20%20border%2Dbottom%3A%201px%20dashed%20%23dddddd%3B%0A%20%20border%2Dtop%3A%201px%20dashed%20%23dddddd%3B%0A%20%20padding%3A%201%2E5em%200%3B%0A%20%20margin%3A%201%2E5em%200%3B%20%7D%0A%20%20nav%20%3E%20ul%20%3E%20li%20%3E%20a%20%7B%0A%20%20%20%20font%2Dweight%3A%20bold%3B%20%7D%0A%0Aheader%20%7B%0A%20%20padding%3A%204%2E5em%200%3B%20%7D%0A%0Abody%20%7B%0A%20%20%2Dwebkit%2Dfont%2Dsmoothing%3A%20antialiased%3B%0A%20%20color%3A%20%23444444%3B%0A%20%20font%2Dfamily%3A%20%22proxima%2Dnova%22%2C%20%22Helvetica%20Neue%22%2C%20Helvetica%2C%20Arial%2C%20sans%2Dserif%3B%0A%20%20line%2Dheight%3A%201%2E5em%3B%20%7D%0A%0Ah1%2C%20h2%2C%20h3%2C%20h4%2C%20h5%2C%20h6%20%7B%0A%20%20color%3A%20%23222222%3B%0A%20%20font%2Dfamily%3A%20%22proxima%2Dnova%22%2C%20%22Helvetica%20Neue%22%2C%20Helvetica%2C%20Arial%2C%20sans%2Dserif%3B%0A%20%20line%2Dheight%3A%201%2E25em%3B%0A%20%20margin%3A%201%2E5em%200%200%2E375em%3B%0A%20%20text%2Drendering%3A%20optimizeLegibility%3B%20%7D%0A%20%20h1%20%3E%20a%2C%20h2%20%3E%20a%2C%20h3%20%3E%20a%2C%20h4%20%3E%20a%2C%20h5%20%3E%20a%2C%20h6%20%3E%20a%20%7B%0A%20%20%20%20color%3A%20%23222222%3B%20%7D%0A%0Ah1%20%7B%0A%20%20margin%3A%203em%200%200%2E375em%3B%0A%20%20font%2Dsize%3A%201%2E75em%3B%20%7D%0A%20%20h1%20%3E%20a%20%7B%0A%20%20%20%20color%3A%20%23c32f34%3B%20%7D%0A%20%20%20%20h1%20%3E%20a%3Ahover%2C%20h1%20%3E%20a%3Afocus%20%7B%0A%20%20%20%20%20%20color%3A%20%23222222%3B%20%7D%0A%20%20h1%2Etitle%20%7B%0A%20%20%20%20font%2Dsize%3A%203em%3B%0A%20%20%20%20font%2Dweight%3A%20900%3B%0A%20%20%20%20line%2Dheight%3A%201%3B%0A%20%20%20%20margin%3A%200%200%20%2E125em%3B%20%7D%0A%20%20%20%20%40media%20screen%20and%20%28min%2Dwidth%3A%20600px%29%20%7B%0A%20%20%20%20%20%20h1%2Etitle%20%7B%0A%20%20%20%20%20%20%20%20font%2Dsize%3A%204em%3B%20%7D%20%7D%0A%0Ah2%20%7B%0A%20%20font%2Dsize%3A%201em%3B%0A%20%20letter%2Dspacing%3A%201px%3B%0A%20%20text%2Dtransform%3A%20uppercase%3B%20%7D%0A%20%20h2%2Eauthor%20%7B%0A%20%20%20%20color%3A%20%23999999%3B%0A%20%20%20%20float%3A%20left%3B%0A%20%20%20%20font%2Dsize%3A%201em%3B%0A%20%20%20%20font%2Dweight%3A%20200%3B%0A%20%20%20%20margin%3A%200%3B%0A%20%20%20%20text%2Dtransform%3A%20none%3B%20%7D%0A%20%20%20%20%40media%20screen%20and%20%28min%2Dwidth%3A%20600px%29%20%7B%0A%20%20%20%20%20%20h2%2Eauthor%20%7B%0A%20%20%20%20%20%20%20%20font%2Dsize%3A%201%2E25em%3B%20%7D%20%7D%0A%20%20%20%20h2%2Eauthor%3Anot%28%3Alast%2Dchild%29%20%7B%0A%20%20%20%20%20%20margin%2Dright%3A%201em%3B%20%7D%0A%0Ah3%20%7B%0A%20%20font%2Dsize%3A%201em%3B%20%7D%0A%0Ah4%20%7B%0A%20%20font%2Dsize%3A%201%2E5em%3B%20%7D%0A%0Ah5%20%7B%0A%20%20font%2Dsize%3A%201%2E25em%3B%20%7D%0A%0Ah6%20%7B%0A%20%20font%2Dsize%3A%201em%3B%20%7D%0A%0Ap%20%7B%0A%20%20margin%3A%200%200%200%2E75em%3B%20%7D%0A%0Aa%20%7B%0A%20%20%2Dmoz%2Dtransition%3A%20all%200%2E15s%20ease%2Dout%200%3B%0A%20%20%2Dwebkit%2Dtransition%3A%20all%200%2E15s%20ease%2Dout%200%3B%0A%20%20color%3A%20%23477dca%3B%0A%20%20text%2Ddecoration%3A%20none%3B%0A%20%20transition%3A%20all%200%2E15s%20ease%2Dout%200%3B%20%7D%0A%20%20a%3Ahover%20%7B%0A%20%20%20%20color%3A%20%232c5999%3B%20%7D%0A%20%20a%3Aactive%2C%20a%3Afocus%20%7B%0A%20%20%20%20color%3A%20%232c5999%3B%0A%20%20%20%20outline%3A%20none%3B%20%7D%0A%0Ahr%20%7B%0A%20%20border%3A%20none%3B%0A%20%20border%2Dbottom%3A%201px%20solid%20%23dddddd%3B%0A%20%20margin%3A%201%2E5em%200%3B%20%7D%0A%0Aimg%20%7B%0A%20%20margin%3A%200%3B%0A%20%20max%2Dwidth%3A%20100%25%3B%20%7D%0A%0Acode%20%7B%0A%20%20font%2Dfamily%3A%20inconsolata%2C%20%22Bitstream%20Vera%20Sans%20Mono%22%2C%20Consolas%2C%20Courier%2C%20monospace%3B%0A%20%20font%2Dsize%3A%20%2E875em%3B%0A%20%20white%2Dspace%3A%20pre%3B%0A%20%20word%2Dwrap%3A%20break%2Dword%3B%20%7D%0A%0Apre%20%7B%0A%20%20background%3A%20%23f7f7f7%3B%0A%20%20border%3A%201px%20solid%20%23dddddd%3B%0A%20%20line%2Dheight%3A%201%2E35%3B%0A%20%20overflow%2Dx%3A%20scroll%3B%0A%20%20padding%3A%20%2E5rem%201rem%3B%0A%20%20white%2Dspace%3A%20pre%3B%0A%20%20word%2Dwrap%3A%20normal%3B%20%7D%0A%20%20pre%20code%20%7B%0A%20%20%20%20word%2Dwrap%3A%20normal%3B%20%7D%0A%0Ablockquote%20%7B%0A%20%20border%2Dleft%3A%202px%20solid%20%23dddddd%3B%0A%20%20color%3A%20%236a6a6a%3B%0A%20%20margin%3A%201%2E5em%200%3B%0A%20%20padding%2Dleft%3A%200%2E75em%3B%20%7D%0A" rel="stylesheet">
  <script type="text/javascript">
    (function() {
      var config = {
        kitId: 'bgd6ksj',
        scriptTimeout: 3000
      };
      var h=document.getElementsByTagName("html")[0];h.className+=" wf-loading";var t=setTimeout(function(){h.className=h.className.replace(/(\s|^)wf-loading(\s|$)/g," ");h.className+=" wf-inactive"},config.scriptTimeout);var tk=document.createElement("script"),d=false;tk.src='//use.typekit.net/'+config.kitId+'.js';tk.type="text/javascript";tk.async="true";tk.onload=tk.onreadystatechange=function(){var a=this.readyState;if(d||a&&a!="complete"&&a!="loaded")return;d=true;clearTimeout(t);try{Typekit.load(config)}catch(b){}};var s=document.getElementsByTagName("script")[0];s.parentNode.insertBefore(tk,s)
    })();
  </script>
</head>
<body>
<header>
<h1 class="title">Goal-Oriented Git</h1>
<h2 class="author">George Brocklehurst</h2>
</header>
<nav id="TOC">
<ul>
<li><a href="#about-this-book">About this book</a></li>
<li><a href="#goal-get-set-up">Goal: Get set up</a><ul>
<li><a href="#what-is-git">What is Git?</a></li>
<li><a href="#using-the-command-line">Using the command line</a></li>
<li><a href="#installing-and-configuring-git">Installing and configuring Git</a></li>
</ul></li>
<li><a href="#goal-track-changes">Goal: Track changes</a><ul>
<li><a href="#the-git-init-command">The <code>git init</code> command</a></li>
<li><a href="#the-git-add-and-git-commit-commands">The <code>git add</code> and <code>git commit</code> commands</a></li>
<li><a href="#summary">Summary</a></li>
</ul></li>
<li><a href="#goal-understand-what-is-being-tracked">Goal: Understand what is being tracked</a><ul>
<li><a href="#the-git-status-command">The <code>git status</code> command</a></li>
<li><a href="#the-git-diff-command">The <code>git diff</code> command</a><ul>
<li><a href="#the-git-diff---staged-command">The <code>git diff --staged</code> command</a></li>
</ul></li>
<li><a href="#summary-1">Summary</a></li>
</ul></li>
<li><a href="#goal-make-beautiful-commits">Goal: Make beautiful commits</a><ul>
<li><a href="#the-git-add---patch-command">The <code>git add --patch</code> command</a></li>
<li><a href="#summary-2">Summary</a></li>
</ul></li>
<li><a href="#goal-read-the-history">Goal: Read the history</a><ul>
<li><a href="#the-git-log-command">The <code>git log</code> command</a></li>
<li><a href="#the-git-show-command">The <code>git show</code> command</a></li>
<li><a href="#summary-3">Summary</a></li>
</ul></li>
<li><a href="#goal-refer-to-commits">Goal: Refer to commits</a><ul>
<li><a href="#abbreviating-commit-identifiers">Abbreviating commit identifiers</a></li>
<li><a href="#relative-commit-references">Relative commit references</a></li>
<li><a href="#using-the-commit-message">Using the commit message</a></li>
<li><a href="#there-are-more">There are more!</a></li>
<li><a href="#summary-4">Summary</a></li>
</ul></li>
<li><a href="#goal-understand-a-change">Goal: Understand a change</a><ul>
<li><a href="#the-git-blame-command">The <code>git blame</code> command</a></li>
<li><a href="#filtering-git-log-by-commit-and-file-name">Filtering <code>git log</code> by commit and file name</a></li>
<li><a href="#summary-5">Summary</a></li>
</ul></li>
<li><a href="#goal-search-the-repository">Goal: Search the repository</a><ul>
<li><a href="#filtering-git-log-by-content">Filtering <code>git log</code> by content</a></li>
<li><a href="#the-git-grep-command">The <code>git grep</code> command</a></li>
<li><a href="#summary-6">Summary</a></li>
</ul></li>
<li><a href="#goal-undo-changes">Goal: Undo changes</a><ul>
<li><a href="#the-git-revert-command">The <code>git revert</code> command</a></li>
<li><a href="#the-git-reset-command">The <code>git reset</code> command</a><ul>
<li><a href="#remove-changes-from-the-index">Remove changes from the index</a></li>
<li><a href="#remove-commits-from-the-repository">Remove commits from the repository</a></li>
</ul></li>
</ul></li>
<li><a href="#introduction">Introduction</a></li>
<li><a href="#goal-create-a-branch">Goal: Create a branch</a></li>
<li><a href="#goal-compare-branches">Goal: Compare branches</a></li>
<li><a href="#goal-combine-branches">Goal: Combine branches</a></li>
<li><a href="#goal-move-branches">Goal: Move branches</a></li>
<li><a href="#goal-delete-branches">Goal: Delete branches</a></li>
<li><a href="#introduction-1">Introduction</a></li>
<li><a href="#goal-add-a-remote">Goal: Add a remote</a></li>
<li><a href="#goal-publish-changes">Goal: Publish changes</a></li>
<li><a href="#goal-retrieve-changes">Goal: Retrieve changes</a></li>
</ul>
</nav>
<p></p>
<section id="about-this-book" class="level1">
<h1>About this book</h1>
<p>If you want to learn how to use Git without worrying too much about what's going on under the hood, then this book is for you.</p>
<p>Every chapter will take something that Git can do for you---from tracking changes, to searching your files, to collaborating with others---and explain practically how to achieve that goal. We won't cover everything Git can do, but we won't just stick to the basics either: the goal of this book is to teach you a working set of Git commands that can get you through most day-to-day situations.</p>
<p>If you're learning Git for the first time, I'd recommend reading through in order: When we look at a particular goal, I'll assume knowledge of commands that were covered in earlier chapters.</p>
<p></p>
<p></p>
</section>
<section id="goal-get-set-up" class="level1">
<h1>Goal: Get set up</h1>
<section id="what-is-git" class="level2">
<h2>What is Git?</h2>
<p>Git is a <dfn>version control system</dfn>. When you work on a project---whether it's a piece of software, a Web site, a book, or anything else that goes through many revisions---using version control lets you track the changes that you make, return to previous versions, try alternative ideas, and seamlessly merge your own work with the work of others.</p>
<p>Git can track any kind of files, but it's best suited to <dfn>plain text files</dfn>. If you're not familiar with the term, these are files that just contain unformatted text as opposed to images or things like <abbr title="Portable Document Format">PDF</abbr>.</p>
</section>
<section id="using-the-command-line" class="level2">
<h2>Using the command line</h2>
<p>Everything covered in this book will be done from the command line. While there are various applications that provide graphical interfaces for Git, the command line interface is powerful, flexible, and works on every platform. Issuing commands, one-by-one, forces us to take things step-by-step so we can really understand what's happening.</p>
<p>If you're not familiar with using command line tools, then there are a few terms you'll need to know. Here's a typical Git command:</p>
<pre><code>git commit --message &quot;My first commit&quot;</code></pre>
<p>We'll cover what it does later, but for now let's name its component parts:</p>
<ul>
<li><code>git</code> is the <dfn>command</dfn>: it's the name of the program we want to run.</li>
<li><code>commit</code> is the <dfn>sub-command</dfn>: it tells Git what we want it to do. Not all command line interfaces use sub-commands, but since Git uses them for almost everything, in the context of this book we can just think of <code>git commit</code> as the command.</li>
<li><code>--message</code> and <code>&quot;My first commit&quot;</code> are both <dfn>arguments</dfn>: they are passed to the command to further nuance its behaviour. Arguments often come in pairs, where we tell Git what option we want to use---in this case <code>--message</code>---and then a value for that option---<code>&quot;My first commit&quot;</code>.</li>
</ul>
</section>
<section id="installing-and-configuring-git" class="level2">
<h2>Installing and configuring Git</h2>
<p>Before we begin, you'll need to install Git and get it set up:</p>
<ol type="1">
<li>Go to the Git downloads page, and follow the instructions for your operating system: <a href="http://git-scm.com/downloads">http://git-scm.com/downloads</a></li>
<li><p>Make sure you can run Git commands from the command line. If you're on Mac OS X you can use the Terminal.app application; if you're on Windows there's an application called <i>Git Bash</i> that comes with Git.</p>
<p>The following command should tell you what version of Git you have installed:</p>
<pre><code>$ git --version
git version 2.2.1</code></pre>
<p>As with all of the examples in this book, the <code>$</code> at the beginning of the line indicates that this is a command; you shouldn't include it in the command you type.</p>
If you see a version number, as show above, then Git is installed successfully. If you see a message along the lines of <code>command not found</code>, then Git isn't correctly installed yet.</li>
<li><p>When Git is tracking changes to our files, it needs to know who made those changes---we'll see why this is important when we explore Git's collaborative features in Part 4.</p>
<p>To identify yourself, and therefore the changes you track with Git, you need to set Git's <code>user.name</code> and <code>user.email</code> settings with the following commands, replacing my name and email address with your own:</p>
<pre><code>$ git config --global user.name &quot;George Brocklehurst&quot;
$ git config --global user.email george@georgebrock.com</code></pre>
<p>The <code>--global</code> argument tells Git that these settings should apply to all of the Git projects you work on, so you'll only need to set this once. Don't worry if you don't completely follow this now; we'll talk about the <code>git config</code> command in more detail later in the book.</p></li>
</ol>
</section>
</section>
<section id="goal-track-changes" class="level1">
<h1>Goal: Track changes</h1>
<p>If you can see how the incremental changes to your files led to their current state, then you have a better chance of understanding the project you are working on, fixing problems that arise, and collaborating successfully with others. In order to unlock the riches promised by a comprehensive history, we have to first build that history, one change at a time.</p>
<p>By now, you should have installed Git on your system, and so you are ready to create your first Git repository.</p>
<p>A <dfn>repository</dfn> is the place where Git keeps track of all of the changes for a given project. We need to create a repository for each project we want to track with Git.</p>
<section id="the-git-init-command" class="level2">
<h2>The <code>git init</code> command</h2>
<p>The <code>git init</code> command creates a new Git repository to keep track of changes to the files in the directory where the command is run. For example:</p>
<pre><code>$ cd projects/git-book
$ git init
Initialized empty Git repository in /home/george/projects/git-book/.git/</code></pre>
<p>This creates a new Git repository in the <code>projects/git-book</code> directory, telling Git that from now on we want to track the changes made to one or more of the files in that directory. Since we haven't told Git exactly which files to track yet, the repository is empty; this is true even if the <code>projects/git-book</code> directory isn't empty.</p>
<p>Running the command creates a new directory, <code>projects/git-book/.git</code>, where Git will store the files that represent the repository. This is the <dfn>Git directory</dfn>, whereas <code>projects/git-book</code> is the <dfn>working directory</dfn>.</p>
<p>To begin with, we'll modify files in the working directory, just as we would if we weren't using Git, and then tell Git to track the changes we've made in the repository. As we get more advanced, we'll be able to conjure old or alternative versions of our project from the repository, summoning them to the working directory to do our bidding.</p>
</section>
<section id="the-git-add-and-git-commit-commands" class="level2">
<h2>The <code>git add</code> and <code>git commit</code> commands</h2>
<p>The individual changes that make up the history of our project are called <dfn>commits</dfn>. We commit changes to the Git repository in the same way we might commit something to memory; once it's committed we won't lose it.</p>
<p>Each commit consists of a set of changes---like adding a new file, changing the contents of a file, deleting a file, or changing the properties of the file in some way---and a <dfn>commit message</dfn> that describes the changes, and the name and email address of the commit's author.</p>
<p>Git provides a staging area called the <dfn>index</dfn>, where we build up a set of changes before committing them to the repository. We'll come back to why the index is useful later, but for now it's enough to know that creating a commit is a three stage process:</p>
<ol type="1">
<li>Change files in the working directory.</li>
<li>Add some or all of those changes to the index.</li>
<li>Create a commit from the changes staged in the index.</li>
</ol>
<p>Let's say we've created a file in our <code>git-book</code> working directory called <code>chapter1.txt</code>, and we're happy with the contents of the file and want to commit it to the repository. That's step one, step two is to add the file to the index using the <code>git add</code> command:</p>
<pre><code>$ git add chapter1.txt</code></pre>
<p>And then we can create a commit using the <code>git commit</code> command:</p>
<pre><code>$ git commit --message &quot;Add first draft of chapter one&quot;
[master (root-commit) adf6af9] Add first draft of chapter one
 1 file changed, 1 insertion(+)
 create mode 100644 chapter1.txt</code></pre>
<p>The commit message, passed using the <code>--message</code> argument, describes the changes in the commit: in this case, it adds the first draft of chapter one.</p>
<p>By committing, we've drawn a line in the sand. Whatever changes we make to chapter one in future, we'll always be able to get back to this <dfn>revision</dfn> of the file. Even though a commit only contains the changes made to a file since it was last committed, we can think of a commit as representing a particular revision of our project, since Git is able to use all of the commits up to that point to reconstruct the revision of the project that existed when that commit was made.</p>
<p>Now that we've included it in a commit, the file <code>chapter1.txt</code> will be <dfn>tracked</dfn> by Git: if we make any changes to the file in future, Git will notice that it has changed and needs to be committed again.</p>
</section>
<section id="summary" class="level2">
<h2>Summary</h2>
<ul>
<li>Create a new Git repository with <code>git init</code></li>
<li>Stage related changes in the index with <code>git add</code></li>
<li>Commit the changes in the index with <code>git commit</code></li>
</ul>
</section>
</section>
<section id="goal-understand-what-is-being-tracked" class="level1">
<h1>Goal: Understand what is being tracked</h1>
<p>So far, we've made simple commits with just one file, but in a complex project there could be dozens or even hundreds of files. How do we know if they've been changed since they were last committed, or if they're even tracked by Git?</p>
<p>In the last chapter we defined three important locations:</p>
<ol type="1">
<li>The working directory, where we keep and work on the current version of our project's files.</li>
<li>The index, where we build up a set of changes ready to commit.</li>
<li>The repository, where Git stores the history of our project as a series of commits.</li>
</ol>
<p>Git provides a number of commands for comparing the state of the repository, the index, and the working directory, so we can stay up to date with what's changed.</p>
<section id="the-git-status-command" class="level2">
<h2>The <code>git status</code> command</h2>
<p>The <code>git status</code> command will tell us the status of our files. It lists all of the changed or untracked files in the working directory, split into the following groups:</p>
<ol type="1">
<li><strong>Changes to be committed</strong>: files which have already been added to the index with <code>git add</code> and will be included the next time we run <code>git    commit</code>.</li>
<li><strong>Changes not staged for commit</strong>: files which have been changed in the working directory, but not added to the index.</li>
<li><strong>Untracked files</strong>: files which have never been committed and therefore aren't tracked by Git.</li>
</ol>
<p>For example:</p>
<pre><code>$ git status
HEAD detached from eec7d91
Changes to be committed:
  (use &quot;git reset HEAD &lt;file&gt;...&quot; to unstage)

    new file:   chapter2.txt

Changes not staged for commit:
  (use &quot;git add &lt;file&gt;...&quot; to update what will be committed)
  (use &quot;git checkout -- &lt;file&gt;...&quot; to discard changes in working directory)

    modified:   chapter1.txt

Untracked files:
  (use &quot;git add &lt;file&gt;...&quot; to include in what will be committed)

    chapter3.txt
</code></pre>
<p>In this case, <code>chapter2.txt</code> has just been added to the index for the first time with <code>git add</code>, <code>chapter1.txt</code> is tracked by Git but has been modified since it was last committed, and <code>chapter3.txt</code> isn't tracked by Git yet.</p>
<p><code>git status</code> won't mention any files that haven't been changed since they were last committed. If none of your files have changed, <code>git status</code> will let you know that you have clean working directory:</p>
<pre><code>$ git status
HEAD detached from eec7d91
nothing to commit, working directory clean</code></pre>
<p><code>git status</code> isn't concerned with the details of exactly what's changed in each file, just which files have been changed and therefore could be committed.</p>
</section>
<section id="the-git-diff-command" class="level2">
<h2>The <code>git diff</code> command</h2>
<p>Now we know which files in our working directory have changed, it would be good to see the details of those changes. The <code>git diff</code> command provides this.</p>
<p>If you've used the Unix <code>diff</code> utility then the output of <code>git diff</code> might look familiar, but while <code>diff</code> shows the difference between files, <code>git diff</code> shows the difference between versions of the same file.</p>
<p>Without any arguments, <code>git diff</code> shows all changes that haven't been committed or added to the index.</p>
<p>For example, here's what <code>chapter1.txt</code> the list time it was committed:</p>
<pre><code>CHAPTER ONE

This is the first chapter, where it all begins.</code></pre>
<p>Since that commit, we've modified <code>chapter1.txt</code> in the working directory to look like this:</p>
<pre><code>CHAPTER 1

This is the first chapter, where it all begins.</code></pre>
<p>Running <code>git diff</code> shows us exactly what the differences are:</p>
<pre><code>$ git diff
diff --git a/chapter1.txt b/chapter1.txt
index 1e41245..80a7940 100644
--- a/chapter1.txt
+++ b/chapter1.txt
@@ -1,3 +1,3 @@
-CHAPTER ONE
+CHAPTER 1
 
 This is the first chapter, where it all begins.</code></pre>
<p>The first section gives some information about the change Git is showing: which versions are being compared, and on which lines of which files there are changes. Other than the file's name, this is more useful to machines than humans, and I usually don't read it carefully. More important are the changes themselves:</p>
<pre><code>-CHAPTER ONE
+CHAPTER 1
 
 This is the first chapter, where it all begins.</code></pre>
<p>Lines beginning with a <code>-</code> indicate a line that has been removed, and lines beginning with a <code>+</code> indicate a line that has been added. In this case a line has been changed: the old version of the line was removed, and the new version was added.</p>
<p>Lines beginning with a space---lines that lack both <code>+</code> and <code>-</code>---are unchanged, but are shown to give the context of the change.</p>
<section id="the-git-diff---staged-command" class="level3">
<h3>The <code>git diff --staged</code> command</h3>
<p>Remember that without any arguments <code>git diff</code> shows us the changes that haven't been staged in the index yet. <code>git diff --staged</code> shows us the changes that <em>have</em> been staged, but haven't yet been committed. In other words, <code>git diff --staged</code> shows you the changes that would be included in the commit, if you were to run <code>git commit</code> right now.</p>
<p>It can be useful to run <code>git diff --staged</code> before <code>git commit</code> as a final check that the right changes have been staged in the index.</p>
</section>
</section>
<section id="summary-1" class="level2">
<h2>Summary</h2>
<ul>
<li>Look at the state of the working directory with <code>git status</code></li>
<li>Look at the changes since the latest commit with <code>git diff</code></li>
<li>Look at the contents of the index with <code>git diff --staged</code></li>
</ul>
</section>
</section>
<section id="goal-make-beautiful-commits" class="level1">
<h1>Goal: Make beautiful commits</h1>
<p>A good commit should contain a set of related changes, with a description of why those changes were made. Much of the power of tracking history is lost if we bundle lots of unrelated changes together in the same commit, or don't take the time to describe them properly.</p>
<p>So far we've been assuming that all of the changes to a file belong in the same commit. Real world work is rarely this neat and tidy, though. Perhaps we were half way through changing a document, and found ourselves fixing an un-related typing error; perhaps we forgot to commit a set of changes before moving on to the next idea; perhaps we just got distracted: whatever the cause, a real project's working directory can be a messy place.</p>
<p>This is where the index really comes into its own: By updating the index before we commit, we can carefully select the changes that go into each commit; even going so far as to split unrelated changes to the same file over several commits.</p>
<section id="the-git-add---patch-command" class="level2">
<h2>The <code>git add --patch</code> command</h2>
<p>In addition to the name of a file, the <code>git add</code> command can take some options to control exactly what is added to the index. Particularly useful is the <code>--patch</code> option, which shows you each change in turn and lets you decide if it should be added to the index or not.</p>
<p>Let's look at an example: I've made two changes to the same file but they are unrelated, so I want to add them to the repository as two separate commits. <code>git diff</code> tells me I have the following changes:</p>
<pre><code>$ git diff
diff --git a/chapter1.txt b/chapter1.txt
index 8f6f18e..d119536 100644
--- a/chapter1.txt
+++ b/chapter1.txt
@@ -1,3 +1,3 @@
-The quick brown fxo jumped over the lazy dog.
+The quick brown fox jumped over the lazy dog.
 
-The dog was not best pleased.
+The dog was not best pleased, and barked angrily.</code></pre>
<p>On the first line, I've corrected a typing error by changing <code>fxo</code> to <code>fox</code>, and then on the third line I've added some additional material about the dog's reaction to the fox. <code>git add --patch</code> will allow us to go through each change in turn, and decide if we want to add it to the index.</p>
<pre><code>$ git add --patch
diff --git a/chapter1.txt b/chapter1.txt
index 8f6f18e..d119536 100644
--- a/chapter1.txt
+++ b/chapter1.txt
@@ -1,3 +1,3 @@
-The quick brown fxo jumped over the lazy dog.
+The quick brown fox jumped over the lazy dog.
 
-The dog was not best pleased.
+The dog was not best pleased, and barked angrily.
Stage this hunk [y,n,q,a,d,/,s,e,?]? 
</code></pre>
<p>Git will show the changes---using the familiar style of <code>git diff</code>---one at a time, and asks me what I want to do with each <dfn>hunk</dfn> with the question <code>Stage this hunk [y,n,q,a,d,/,s,e,?]?</code>. Most of the time we can answer with <code>y</code> to add the change to the index, or <code>n</code> to ignore it for now and move on to the next change. In this case, it's a little more complicated: since my changes are very close together, Git's assumed that they're probably related and shows them as a single hunk. I want to split up this hunk, and since I need something beyond a basic &quot;yes&quot; or &quot;no&quot; I can use <code>?</code> to explain the other options:</p>
<pre><code>Stage this hunk [y,n,q,a,d,/,s,e,?]? ?
y - stage this hunk
n - do not stage this hunk
q - quit; do not stage this hunk or any of the remaining ones
a - stage this hunk and all later hunks in the file
d - do not stage this hunk or any of the later hunks in the file
g - select a hunk to go to
/ - search for a hunk matching the given regex
j - leave this hunk undecided, see next undecided hunk
J - leave this hunk undecided, see next hunk
k - leave this hunk undecided, see previous undecided hunk
K - leave this hunk undecided, see previous hunk
s - split the current hunk into smaller hunks
e - manually edit the current hunk
? - print help</code></pre>
<p>After looking through my options, I see I can use <code>s</code> to tell Git that even though these changes are close to each other they should be split up so that I can treat them differently:</p>
<pre><code>Stage this hunk [y,n,q,a,d,/,s,e,?]? s
Split into 2 hunks.
@@ -1,2 +1,2 @@
-The quick brown fxo jumped over the lazy dog.
+The quick brown fox jumped over the lazy dog.
 
Stage this hunk [y,n,q,a,d,/,j,J,g,e,?]? </code></pre>
<p>Git splits the change into two hunks, and shows me the first of them. This change is just the correction on the first line, so I can stage it in the index using <code>y</code>. Once it's staged, Git will show me the next change. Since this change isn't related to the one I've already added to the index, I don't want to include it in the same commit, so I can skip it with <code>n</code>:</p>
<pre><code>Stage this hunk [y,n,q,a,d,/,j,J,g,e,?]? y
@@ -2,2 +2,2 @@
 
-The dog was not best pleased.
+The dog was not best pleased, and barked angrily.
Stage this hunk [y,n,q,a,d,/,K,g,e,?]? n</code></pre>
<p>I've now made a decision about each of the changes to the tracked files in my working directory, so <code>git add --patch</code> exits, and I can commit the correction that's staged, and then stage and commit the additional content:</p>
<pre><code>$ git commit --message &quot;Fix typing error&quot;
[master a76fa02] Fix typing error
 1 file changed, 1 insertion(+), 1 deletion(-)
$ git diff
diff --git a/chapter1.txt b/chapter1.txt
index 9d07dc3..d119536 100644
--- a/chapter1.txt
+++ b/chapter1.txt
@@ -1,3 +1,3 @@
 The quick brown fox jumped over the lazy dog.
 
-The dog was not best pleased.
+The dog was not best pleased, and barked angrily.
$ git add chapter1.txt
$ git commit --message &quot;Add information about the dog's reaction&quot;
[master 4013a6a] Add information about the dog's reaction
 1 file changed, 1 insertion(+), 1 deletion(-)</code></pre>
<p>I almost always use the <code>--patch</code> option when I'm adding files to the index, even when I'm confident that all of the changes are related and will end up as a single commit: It gives me the opportunity to review my changes, and has saved me many times from committing something that wasn't quite right.</p>
</section>
<section id="summary-2" class="level2">
<h2>Summary</h2>
<ul>
<li>Good commits are focused on a set of related changes</li>
<li>Use <code>git commit --patch</code> to add specific changes to the index</li>
</ul>
<p></p>
</section>
</section>
<section id="goal-read-the-history" class="level1">
<h1>Goal: Read the history</h1>
<p>Now that we've made some commits, we can begin to use them to explore the history of our project.</p>
<p>You'll often want to view your whole commit history. It can be a great way of refreshing your memory about what you were working on, or seeing what others have done on a collaborative project.</p>
<section id="the-git-log-command" class="level2">
<h2>The <code>git log</code> command</h2>
<p>The <code>git log</code> command will show all of the commits, with their authors, dates, and messages:</p>
<pre><code>$ git log
commit 2a40e706eaf92805907a1f3be707a199982ef0f9
Author: George Brocklehurst &lt;george@georgebrock.com&gt;
Date:   Mon Oct 27 15:18:26 2014 -0400

    Draft content for chapter 2

commit c7d5d6876da96f8aff9b08416119ff0178d776cf
Author: George Brocklehurst &lt;george@georgebrock.com&gt;
Date:   Mon Oct 27 15:16:48 2014 -0400

    Draft content for chapter 1</code></pre>
<p>In this example, the project has two commits. The most recent commit is shown first.</p>
<p>Each commit starts with an long string of numbers and letters that uniquely identifies the commit:</p>
<pre><code>commit 2a40e706eaf92805907a1f3be707a199982ef0f9</code></pre>
<p>These identifiers are very important. Many of the ways we can use our projects' Git history involve referring to specific commits, and we often do that using these unique identifiers.</p>
<p>Often the full output of <code>git log</code> is more than we need: a short summary of each commit would be enough, without authors, dates, or even the full commit message. The <code>git log</code> command accepts many options to customise the format of the output; one of the most useful is <code>--oneline</code>, which only outputs the first line of the commit message, and the first few characters of the unique identifier:</p>
<pre><code>2a40e70 Draft content for chapter 2
c7d5d68 Draft content for chapter 1</code></pre>
<p>Running <code>git help log</code> will give you comprehensive documentation on the other ways you can customise the output of <code>git log</code>.</p>
</section>
<section id="the-git-show-command" class="level2">
<h2>The <code>git show</code> command</h2>
<p>While <code>git log</code> gives us an overview of many commits, the <code>git show</code> command will show the contents of a specific commit. We need to tell it which commit to show; this is the first of many examples of a place where we can use a commit's unique identifier.</p>
<pre><code>$ git show c7d5d6876da96f8aff9b08416119ff0178d776cf
commit c7d5d6876da96f8aff9b08416119ff0178d776cf
Author: George Brocklehurst &lt;george@georgebrock.com&gt;
Date:   Mon Oct 27 15:16:48 2014 -0400

    Draft content for chapter 1

diff --git a/chapter1.txt b/chapter1.txt
new file mode 100644
index 0000000..b5689b5
--- /dev/null
+++ b/chapter1.txt
@@ -0,0 +1 @@
+Chapter 1: This is the first chapter.</code></pre>
<p>The output should all be familiar: it starts with information about the commit, which is very similar to the output produced by <code>git log</code>, and then shows the changes made by the commit, which is very similar to the output produced by <code>git diff</code>.</p>
</section>
<section id="summary-3" class="level2">
<h2>Summary</h2>
<ul>
<li>Use <code>git log</code> to see a list of commits.</li>
<li>Use <code>git log --oneline</code> to see just the first line of the commit messages.</li>
<li>Use <code>git show &lt;identifier&gt;</code> to see the contents of a specific commit.</li>
</ul>
</section>
</section>
<section id="goal-refer-to-commits" class="level1">
<h1>Goal: Refer to commits</h1>
<p>In the last chapter we learnt how to use the <code>git log</code> command to find a commit's identifier, which we could use with the <code>git show</code> command to view the contents of that commit.</p>
<p>Commit identifiers can be quite cumbersome to use: they're long, complex, and not very memorable. Fortunately, Git provides a range of alternatives.</p>
<p>Let's imagine the following Git history, and see how we can refer to the commits without using the long-winded commit identifiers:</p>
<pre><code>$ git log
commit e420911b9d16d0fd75a12a71202673ae32fc933a
Author: George Brocklehurst &lt;george@georgebrock.com&gt;
Date:   Mon Oct 27 15:25:32 2014 -0400

    Third commit

commit 25cece8870c50144c68b5fe27a03aeb647b28c4a
Author: George Brocklehurst &lt;george@georgebrock.com&gt;
Date:   Mon Oct 27 15:25:29 2014 -0400

    Second commit

commit d8084d3fb7f9924dcefad1a20da885b1aba28d54
Author: George Brocklehurst &lt;george@georgebrock.com&gt;
Date:   Mon Oct 27 15:25:23 2014 -0400

    First commit</code></pre>
<section id="abbreviating-commit-identifiers" class="level2">
<h2>Abbreviating commit identifiers</h2>
<p>Let's say we want to look at the latest commit. What we've seen so far is <code>git show</code> with the full identifier:</p>
<pre><code>$ git show e420911b9d16d0fd75a12a71202673ae32fc933a
commit e420911b9d16d0fd75a12a71202673ae32fc933a
Author: George Brocklehurst &lt;george@georgebrock.com&gt;
Date:   Mon Oct 27 15:25:32 2014 -0400

    Third commit</code></pre>
<p>In the previous chapter we saw that the <code>git log --oneline</code> command only prints the start of the commit identifier. It does this because it's possible to use the beginning of the identifier to identify a commit, as long as you use enough of it to be unique among all of the commit identifiers in the repository. In practice, this usually means that we can use the first 6 or 7 characters of the identifier without any problems, even in a long running project with thousands of commits.</p>
<pre><code>$ git show e420911
commit e420911b9d16d0fd75a12a71202673ae32fc933a
Author: George Brocklehurst &lt;george@georgebrock.com&gt;
Date:   Mon Oct 27 15:25:32 2014 -0400

    Third commit</code></pre>
<p>If you don't give enough characters to uniquely identify a single commit, Git will let you know that you've provided an ambiguous argument:</p>
<pre><code>$ git show e42
fatal: ambiguous argument 'e42': unknown revision or path not in the working tree.
Use '--' to separate paths from revisions, like this:
'git &lt;command&gt; [&lt;revision&gt;...] -- [&lt;file&gt;...]'</code></pre>
</section>
<section id="relative-commit-references" class="level2">
<h2>Relative commit references</h2>
<p>Each commit in our Git repository has a <dfn>parent commit</dfn>: the commit that immediately preceded it. If we know the identifier of a commit, we can tell Git to give us its parent commit using a <code>~1</code> suffix. For example:</p>
<pre><code>$ git show e420911~1
commit 25cece8870c50144c68b5fe27a03aeb647b28c4a
Author: George Brocklehurst &lt;george@georgebrock.com&gt;
Date:   Mon Oct 27 15:25:29 2014 -0400

    Second commit</code></pre>
<p>By increasing the number after the <code>~</code> we can follow the parent relationships back through the project's history. For example, <code>~2</code> will give us the parent of the parent commit:</p>
<pre><code>$ git show e420911~2
commit d8084d3fb7f9924dcefad1a20da885b1aba28d54
Author: George Brocklehurst &lt;george@georgebrock.com&gt;
Date:   Mon Oct 27 15:25:23 2014 -0400

    First commit</code></pre>
</section>
<section id="using-the-commit-message" class="level2">
<h2>Using the commit message</h2>
<p>These techniques are all great if you know the commit's identifier, or at least the identifier of one of its descendants, but identifiers aren't as memorable as commit messages. Fortunately it's possible to refer to commits using a part of their message, too:</p>
<pre><code>$ git show :/Second
commit 25cece8870c50144c68b5fe27a03aeb647b28c4a
Author: George Brocklehurst &lt;george@georgebrock.com&gt;
Date:   Mon Oct 27 15:25:29 2014 -0400

    Second commit</code></pre>
<p>If there are multiple commits that match the given word, then Git will pick the newest matching commit.</p>
</section>
<section id="there-are-more" class="level2">
<h2>There are more!</h2>
<p>We've only scratched the surface of the many ways of referring to Git commits. If you want all the options, then Git's comprehensive help system is the place to go:</p>
<pre><code>$ git help revisions</code></pre>
<p>If you're reading this book in order to learn Git for the first time, then many of the concepts in that document won't be familiar to you yet, but don't be afraid to explore the documentation.</p>
</section>
<section id="summary-4" class="level2">
<h2>Summary</h2>
<ul>
<li>Use abbreviated commit identifiers.</li>
<li>Use relative commit references, e.g. <code>e420911~2</code>.</li>
<li>Refer to commits using their message, e.g. <code>:/Second</code>.</li>
<li>Check <code>git help revisions</code> for more.</li>
</ul>
</section>
</section>
<section id="goal-understand-a-change" class="level1">
<h1>Goal: Understand a change</h1>
<p>Now that we've learnt how to look at the whole history, and a variety of ways to refer to a specific commit, we're ready to start asking more demanding questions of our Git repository.</p>
<p>It can often be the case in a long running project that we come across something in one of our files that doesn't quite make sense. Using the project's Git history to see where something came from can help to make it more clear. Git can help us answer questions like &quot;why was this changed?&quot; and &quot;what was here before it changed?&quot;</p>
<p>Here's a confusing file called <code>chapter1.txt</code>. Let's dig into the history and see if we can work out what's going on:</p>
<pre><code>There are several things you should know:
Lastly, Git will help you get your work done.</code></pre>
<p>It looks like there should be a list here, but there's only one item, and confusingly it seems like it should be the last item. Maybe this just needs to be rephrased, but maybe something was deleted that shouldn't have been.</p>
<section id="the-git-blame-command" class="level2">
<h2>The <code>git blame</code> command</h2>
<p>The first command we can use to understand this file is <code>git blame</code>, which will tell us which person, and more importantly which commit, is to blame for the current state of each line in the file:</p>
<pre><code>HEAD is now at aaad9ad... Remove contradictory information.
$ git blame chapter1.txt
^61966bf (George Brocklehurst 2014-10-23 11:21:55 -0400 1) There are several things you should know:
^61966bf (George Brocklehurst 2014-10-23 11:21:55 -0400 2) Lastly, Git will help you get your work done.</code></pre>
<p>Each line of the file is printed with some annotations: the abbreviated identifier of the commit in which it was last changed, the author and date of that commit, and the line number.</p>
<p>In this case, both of those lines were last changed in the commit <code>61966bf</code>. The next step in our investigation should probably be to look at that commit and see the full change:</p>
<pre><code>$ git show 61966bf
commit 61966bf14e754946d0ab3a6d8e66c419918c15a8
Author: George Brocklehurst &lt;george@georgebrock.com&gt;
Date:   Thu Oct 23 11:21:55 2014 -0400

    List things readers should know about Git.

diff --git a/chapter1.txt b/chapter1.txt
new file mode 100644
index 0000000..ecefc9c
--- /dev/null
+++ b/chapter1.txt
@@ -0,0 +1,4 @@
+There are several things you should know:
+Firstly, Git is not very good.
+Secondly, Git is quite useful.
+Lastly, Git will help you get your work done.</code></pre>
<p>This is a clue on the road to solving this mystery: we now know that the ambiguous section started as a list, but a couple of items were subsequently removed. It's a good start, but we still don't know why the list was altered. Maybe the correct fix is to rephrase the content, but maybe those list items should never have been removed in the first place.</p>
<p>To find out where the list items went, we can turn to another command we've used before: <code>git log</code>.</p>
</section>
<section id="filtering-git-log-by-commit-and-file-name" class="level2">
<h2>Filtering <code>git log</code> by commit and file name</h2>
<p>We've used <code>git log</code> to look at all of the commits in our project. In this case, we want something more specific. The <code>git log</code> command accepts a range of commits and a file path as arguments, which we can use to only see commits that:</p>
<ol type="1">
<li>happened <em>after</em> the list was first introduced in commit <code>61966bf</code>, and</li>
<li>contain changes to the file <code>chapter1.txt</code>.</li>
</ol>
<p>The most common way to refer to a range of commits is <code>first..last</code>, where <code>first</code> and <code>last</code> both refer to commits, using their identifiers, or one of the other methods we've seen of identifying a commit. Git also allows us to omit the end of the range, assuming when we do so that we mean it to end with the most recent commit. In our case, we want to see everything after commit <code>61966bf</code>, which introduced the list, so we can use the range <code>61966bf..</code>.</p>
<p>Putting this together with the file path <code>chapter1.txt</code>, we get this command:</p>
<pre><code>$ git log 61966bf.. chapter1.txt
commit aaad9ad5001689eeaeca0ef88626debd27801aea
Author: George Brocklehurst &lt;george@georgebrock.com&gt;
Date:   Thu Oct 23 11:22:31 2014 -0400

    Remove contradictory information.</code></pre>
<p>Our carefully filtered log tells us that only one commit touched the file we're interested in during the time we're interested in. Let's take a closer look:</p>
<pre><code>$ git show aaad9ad
commit aaad9ad5001689eeaeca0ef88626debd27801aea
Author: George Brocklehurst &lt;george@georgebrock.com&gt;
Date:   Thu Oct 23 11:22:31 2014 -0400

    Remove contradictory information.

diff --git a/chapter1.txt b/chapter1.txt
index ecefc9c..60ab488 100644
--- a/chapter1.txt
+++ b/chapter1.txt
@@ -1,4 +1,2 @@
 There are several things you should know:
-Firstly, Git is not very good.
-Secondly, Git is quite useful.
 Lastly, Git will help you get your work done.</code></pre>
<p>Finally we have the full context of this confusing file. It started out as a list, but a couple of items were removed because they were contradictory, which left the surrounding content in a confusing state. Now that we have the full story, we can confidently fix the problem.</p>
<p>Not every investigation will follow these steps, but if you understand the commands we've used here you should be able to track down the source of all kinds of problems.</p>
</section>
<section id="summary-5" class="level2">
<h2>Summary</h2>
<ul>
<li>Use <code>git blame &lt;file&gt;</code> to find out which commit last changed the lines in a file.</li>
<li>Use <code>git log &lt;range&gt; &lt;file&gt;</code> to see relevant commits.</li>
</ul>
</section>
</section>
<section id="goal-search-the-repository" class="level1">
<h1>Goal: Search the repository</h1>
<p>In the last chapter, we saw how to filter the output of <code>git log</code> to only show us commits in a certain range, or commits that contain changes to certain files, so we could see what changes had been made. In this chapter we'll start from the other side: we know the change we're interested in, but we don't know when or where it happened.</p>
<p>Git provides some powerful search tools which let us search through the files it is tracking and the commits we've made in the past.</p>
<section id="filtering-git-log-by-content" class="level2">
<h2>Filtering <code>git log</code> by content</h2>
<p>Let's pretend I'm writing a novel, which has the following Git history:</p>
<pre><code>$ git log --oneline
2ba40c1 Remove cafe scene and references
e8393d4 Refer back to the cafe in chapter 2.
1dba13c Add cafe scene
3ba3f98 Remove zoo scene
0e6d7f7 Begin work on chapter 2
597b543 Begin work on chapter 1</code></pre>
<p>I deleted a section of the novel, but I'm having second thoughts: I think the story will flow better if I put it back. Unfortunately, I deleted it some time ago, and I don't remember all of the details, just that it centred around a character called Alice.</p>
<p>There are a few commit messages that mention removing content, but by filtering the commit log to only show commits which contain changes that add or remove the word &quot;Alice&quot;, I can narrow down my search. We do this using <code>git log</code>'s <code>-S</code> option:</p>
<pre><code>$ git log --oneline -S Alice
3ba3f98 Remove zoo scene
0e6d7f7 Begin work on chapter 2
597b543 Begin work on chapter 1</code></pre>
<p>Now I've narrowed down the search to three commits, and only one of the messages mentions removing content, so it looks like I've found my deleted scene.</p>
<pre><code>$ git show 3ba3f98
commit 3ba3f9832331a486d8aeabe6215b3abaa1dfc052
Author: George Brocklehurst &lt;george@georgebrock.com&gt;
Date:   Fri Oct 31 16:44:34 2014 -0400

    Remove zoo scene

diff --git a/chapter2.txt b/chapter2.txt
index 2ba6e57..4961d74 100644
--- a/chapter2.txt
+++ b/chapter2.txt
@@ -1,4 +1,3 @@
 CHAPTER TWO
 
-Alice and Bob went to the zoo. Alice enjoyed learning about the different
-animals, while Bob mostly just enjoyed eating icecream.
+We all know that Bob likes icecream.</code></pre>
<p>The <code>-S</code> option can be combined with the other filtering techniques we've seen, so if I had remembered the file that contained the change, or the range of commits it was part of, I could have narrowed down the search even further.</p>
<p>You can think of filtering the <code>git log</code> as searching in time: Given its knowledge of the history of your project, you're asking Git to tell you about times when certain kinds of changes were made. It's also useful to be able to search in space: given a fixed point in time---in Git's terminology, a specific revision of the project---where does a certain word or phrase appear in the project's tracked files?</p>
</section>
<section id="the-git-grep-command" class="level2">
<h2>The <code>git grep</code> command</h2>
<p>The <code>git grep</code> command searches through all of the tracked files for a particular word or phrase. If you're familiar with the Unix <code>grep</code> utility, you'll find that <code>git grep</code> works in much the same way.</p>
<p>Let's say we want to find all references to Alice in all of the tracked files in the working directory. We can use <code>git grep</code>:</p>
<pre><code>$ git grep Alice
chapter1.txt:There were once two people called Alice and Bob.</code></pre>
<p>This tells me that Alice is currently only mentioned once, in the file <code>chapter1.txt</code>. I know that the commit <code>3ba3f98</code> removed some mentions of Alice---we just used the <code>git log -S</code> command to find it---and I want to find out how often she was mentioned before that commit.</p>
<p>If you've read the chapter on how to &quot;Refer to commits&quot;, you'll know that if we have the ID of a commit, we can use a <code>~1</code> suffix to reference the commit before that commit. In this case, we're interested in the revision before <code>3ba3f98</code>, so we can use <code>3ba3f98~1</code>.</p>
<p>The <code>git grep</code> command can take a commit as a second argument, which tells it to search the particular revision of our project represented by that commit:</p>
<pre><code>$ git grep Alice 3ba3f98~1
3ba3f98~1:chapter1.txt:There were once two people called Alice and Bob.
3ba3f98~1:chapter2.txt:Alice and Bob went to the zoo. Alice enjoyed learning about the different</code></pre>
<p>I've found my answer: Alice used to be mentioned in <code>chapter1.txt</code> and <code>chapter2.txt</code>.</p>
<p><code>git grep</code> can match more than just simple words and phrases: it supports a powerful pattern matching language called Regular Expressions, which means you can search for things like &quot;any two digit number&quot;, or &quot;either the word 'Alice' or the word 'Bob'&quot;. How to write regular expressions is beyond the scope of this book, but there is plenty of information on the Web, and even whole books on the topic.</p>
</section>
<section id="summary-6" class="level2">
<h2>Summary</h2>
<ul>
<li>Find commits that mention a word or phrase with <code>git log -S &lt;word&gt;</code>.</li>
<li>Find tracked files that mention a word or phrase with <code>git grep &lt;word&gt;</code>.</li>
<li>Search previous revisions with <code>git grep &lt;word&gt; &lt;revision&gt;</code>.</li>
</ul>
</section>
</section>
<section id="goal-undo-changes" class="level1">
<h1>Goal: Undo changes</h1>
<p>In the previous chapter, we saw how to use Git's search tools to find a change we were having second thoughts about. Having found the commit, how can we reverse that change? We could use <code>git show</code> to view the changes it introduced and manually unpick them by typing them out again or using copy-and-paste. That would be a lot of manual, error-prone work, and fortunately Git provides tools to undo changes we'd rather hadn't been committed.</p>
<section id="the-git-revert-command" class="level2">
<h2>The <code>git revert</code> command</h2>
<p>The simplest way of undoing the changes in a commit is to use the <code>git revert</code> command. This command creates a new commit which contains the opposite set of changes to the commit we want to undo: if a line was added in the original commit, it will be removed in the new commit, and vice versa.</p>
<p>Here is the commit we identified in the previous chapter:</p>
<pre><code>$ git show 3ba3f98
commit 3ba3f9832331a486d8aeabe6215b3abaa1dfc052
Author: George Brocklehurst &lt;george@georgebrock.com&gt;
Date:   Fri Oct 31 16:44:34 2014 -0400

    Remove zoo scene

diff --git a/chapter2.txt b/chapter2.txt
index 2ba6e57..4961d74 100644
--- a/chapter2.txt
+++ b/chapter2.txt
@@ -1,4 +1,3 @@
 CHAPTER TWO
 
-Alice and Bob went to the zoo. Alice enjoyed learning about the different
-animals, while Bob mostly just enjoyed eating icecream.
+We all know that Bob likes icecream.</code></pre>
<p>When we pass the commit's identifier as an argument to the <code>git revert</code> command, Git will construct the opposite set of changes, and commit them.</p>
<pre><code>$ git revert 3ba3f98
[master 282faf2] Revert &quot;Remove zoo scene&quot;
 1 file changed, 2 insertions(+), 1 deletion(-)</code></pre>
<p>Notice that the output of the <code>git revert</code> command contains the identifier of the new commit.</p>
<pre><code>$ git show 282faf2
commit 282faf2b4c396dc4a25f6ad96cd8e29e63eaab3c
Author: George Brocklehurst &lt;george@georgebrock.com&gt;
Date:   Fri Apr 3 14:56:00 2015 -0400

    Revert &quot;Remove zoo scene&quot;
    
    This reverts commit 3ba3f9832331a486d8aeabe6215b3abaa1dfc052.

diff --git a/chapter2.txt b/chapter2.txt
index 4961d74..2ba6e57 100644
--- a/chapter2.txt
+++ b/chapter2.txt
@@ -1,3 +1,4 @@
 CHAPTER TWO
 
-We all know that Bob likes icecream.
+Alice and Bob went to the zoo. Alice enjoyed learning about the different
+animals, while Bob mostly just enjoyed eating icecream.</code></pre>
<p>Like the <code>git commit</code> command, <code>git revert</code> will open a text editor so that we can write a description of the commit, but unlike <code>git commit</code> it helpfully provides a default commit message with some information about the commit that is being reverted. It's usually a good idea to leave the default message intact---so that you'll be able to recognise a revert commit when you're reading the history---and to add a note to the end to explain <em>why</em> it was useful to revert this commit.</p>
</section>
<section id="the-git-reset-command" class="level2">
<h2>The <code>git reset</code> command</h2>
<p>While <code>git revert</code> is useful for undoing a commit from somewhere back in the distant history of the project, we have other options if we want to undo our most recent commit or commits.</p>
<p>The <code>git reset</code> command will reset the repository back to an earlier state. It's a flexible command that can be used in various ways; we'll see it again later in the book, but for now let's focus on two uses:</p>
<ol type="1">
<li>To remove changes from the index: they will still exist in the working directory, but they won't be included in the next commit.</li>
<li>To remove the last commit or commits from the repository: the commit's changes will still exist in the working directory, but it will be as if they were never committed.</li>
</ol>
<section id="remove-changes-from-the-index" class="level3">
<h3>Remove changes from the index</h3>
<p>Without any arguments, <code>git reset</code> will clear the index without changing the working directory or repository: it undoes the <code>git add</code> command. This kind of reset is useful when you're staging some changes, but you realise that you're not really ready to commit them yet, or that you've staged the wrong changes.</p>
<p>Continuing with my novel, I've made some changes to <code>chapter1.txt</code> that I think are ready to commit, so I add them to the index, and <code>git status</code> shows that they are staged to commit:</p>
<pre><code>$ git add chapter1.txt
$ git status
On branch master
Your branch is up-to-date with 'origin/master'.
Changes to be committed:
  (use &quot;git reset HEAD &lt;file&gt;...&quot; to unstage)

    modified:   chapter1.txt
</code></pre>
<p>I was about to commit, but I've changed my mind: these changes aren't all related, and it would probably be better to split them up over multiple commits. I can remove them from the index using <code>git reset</code>:</p>
<pre><code>$ git reset
Unstaged changes after reset:
M   chapter1.txt</code></pre>
<p><code>git status</code> confirms that <code>chapter1.txt</code> has still been changed, but is no longer staged to commit:</p>
<pre><code>$ git status
On branch master
Your branch is up-to-date with 'origin/master'.
Changes not staged for commit:
  (use &quot;git add &lt;file&gt;...&quot; to update what will be committed)
  (use &quot;git checkout -- &lt;file&gt;...&quot; to discard changes in working directory)

    modified:   chapter1.txt

no changes added to commit (use &quot;git add&quot; and/or &quot;git commit -a&quot;)</code></pre>
</section>
<section id="remove-commits-from-the-repository" class="level3">
<h3>Remove commits from the repository</h3>
<p>When it's given a commit as an argument, <code>git reset</code> will clear the index, and roll the repository back to that revision, as if the subsequent commits had never happened. It won't change the working directory, so the current state of our files won't be lost, but the history of how we got to that state will be.</p>
<p>This kind of reset is useful when you realise that your last commit was too big, and you'd like to break it down as several smaller commits. Or maybe you realise that the changes in your last two commits would make more sense spread across three commits.</p>
<p>Although undoing commits is useful, it should make us a little uncomfortable. Commits are the record of how our project has changed, and if we undo them there's a very real chance that we'll lose some valuable history along the way. Over the last few chapters we've seen a few of the ways that having access to a project's history can help us; hopefully we've seen enough that the idea of throwing part of the history away gives us pause.</p>
<p>Let's see how this works with a real example: I want to undo the last two commits to my novel. First, to refresh our memory, let's look at what those commits contain:</p>
<pre><code>$ git log --oneline
2ba40c1 Remove cafe scene and references
e8393d4 Refer back to the cafe in chapter 2.
1dba13c Add cafe scene
3ba3f98 Remove zoo scene
0e6d7f7 Begin work on chapter 2
597b543 Begin work on chapter 1</code></pre>
<p>Remember that <code>git log</code> shows the most recent commit first, so I'm trying to undo <code>e8393d4</code> and <code>2ba40c1</code>. The first of these commits adds some information about what Bob does at the cafe:</p>
<pre><code>$ git show e8393d4
commit e8393d449377539aeda017d8fbf2fcefe76b9b4c
Author: George Brocklehurst &lt;george@georgebrock.com&gt;
Date:   Fri Oct 31 16:52:30 2014 -0400

    Refer back to the cafe in chapter 2.

diff --git a/chapter2.txt b/chapter2.txt
index 4961d74..07d4e18 100644
--- a/chapter2.txt
+++ b/chapter2.txt
@@ -1,3 +1,4 @@
 CHAPTER TWO
 
-We all know that Bob likes icecream.
+We all know that Bob likes icecream. Sometimes, Bob likes to eat icecream at the
+cafe.</code></pre>
<p>The second commit removes all references to the cafe:</p>
<pre><code>$ git show 2ba40c1
commit 2ba40c104744d3f748ea67ad5c75f16dc7840d78
Author: George Brocklehurst &lt;george@georgebrock.com&gt;
Date:   Fri Oct 31 16:53:19 2014 -0400

    Remove cafe scene and references

diff --git a/chapter1.txt b/chapter1.txt
index aa87c61..0ff7cf0 100644
--- a/chapter1.txt
+++ b/chapter1.txt
@@ -1,6 +1,3 @@
 CHAPTER ONE
 
 There were once two people called Alice and Bob.
-
-There is a cafe in the town where they live, and Bob likes to go there on
-weekends.
diff --git a/chapter2.txt b/chapter2.txt
index 07d4e18..4961d74 100644
--- a/chapter2.txt
+++ b/chapter2.txt
@@ -1,4 +1,3 @@
 CHAPTER TWO
 
-We all know that Bob likes icecream. Sometimes, Bob likes to eat icecream at the
-cafe.
+We all know that Bob likes icecream.</code></pre>
<p>In order to undo these commits, I need to reset the repository to the last revision before they were made: <code>1dba13c</code>.</p>
<pre><code>$ git reset 1dba13c
Unstaged changes after reset:
M   chapter1.txt</code></pre>
<p>This doesn't change the working directory, but I have lost some information in the process. Let's look at the state of the repository after I reset:</p>
<pre><code>$ git log --oneline
1dba13c Add cafe scene
3ba3f98 Remove zoo scene
0e6d7f7 Begin work on chapter 2
597b543 Begin work on chapter 1</code></pre>
<p>The log looks good: the two commits we wanted to undo are gone. How about the working directory?</p>
<pre><code>$ git status
On branch master
Your branch is behind 'origin/master' by 2 commits, and can be fast-forwarded.
  (use &quot;git pull&quot; to update your local branch)
Changes not staged for commit:
  (use &quot;git add &lt;file&gt;...&quot; to update what will be committed)
  (use &quot;git checkout -- &lt;file&gt;...&quot; to discard changes in working directory)

    modified:   chapter1.txt

no changes added to commit (use &quot;git add&quot; and/or &quot;git commit -a&quot;)</code></pre>
<p>The status looks OK, too: there are some uncommitted changes in the working directory, but the commits we just removed made changes to both <code>chapter1.txt</code> and <code>chapter2.txt</code>, and yet our working directory only has changes to <code>chapter1.txt</code>:</p>
<pre><code>$ git diff
diff --git a/chapter1.txt b/chapter1.txt
index aa87c61..0ff7cf0 100644
--- a/chapter1.txt
+++ b/chapter1.txt
@@ -1,6 +1,3 @@
 CHAPTER ONE
 
 There were once two people called Alice and Bob.
-
-There is a cafe in the town where they live, and Bob likes to go there on
-weekends.</code></pre>
<p>The changes to <code>chapter2.txt</code> in our two deleted commits cancelled each other out: the first commit added a sentence about what Bob did at the cafe, and the second took it away again. By using <code>git reset</code> to remove these two commits, we've lost a potentially useful bit of history; there's no longer any record that this sentence ever existed, which means we no longer have the option of recovering it if we change our minds. Equally importantly, the information associated with the two commits is gone too: we no longer know who made those commits, when, or why.</p>
<p><code>git reset</code> is a useful tool, but it should be used with caution, and is least risky when used to undo a single commit immediately after it was made. Git is a powerful tool, and will often give us more than enough rope to hang ourselves.</p>
<p></p>
</section>
</section>
</section>
<section id="introduction" class="level1">
<h1>Introduction</h1>
<p>STUB</p>
</section>
<section id="goal-create-a-branch" class="level1">
<h1>Goal: Create a branch</h1>
<p>STUB</p>
</section>
<section id="goal-compare-branches" class="level1">
<h1>Goal: Compare branches</h1>
<p>STUB</p>
</section>
<section id="goal-combine-branches" class="level1">
<h1>Goal: Combine branches</h1>
<p>STUB</p>
</section>
<section id="goal-move-branches" class="level1">
<h1>Goal: Move branches</h1>
<p>STUB</p>
</section>
<section id="goal-delete-branches" class="level1">
<h1>Goal: Delete branches</h1>
<p>STUB</p>
<p></p>
</section>
<section id="introduction-1" class="level1">
<h1>Introduction</h1>
<p>STUB</p>
</section>
<section id="goal-add-a-remote" class="level1">
<h1>Goal: Add a remote</h1>
<p>STUB</p>
</section>
<section id="goal-publish-changes" class="level1">
<h1>Goal: Publish changes</h1>
<p>STUB</p>
</section>
<section id="goal-retrieve-changes" class="level1">
<h1>Goal: Retrieve changes</h1>
<p>STUB</p>
</section>
</body>
</html>
